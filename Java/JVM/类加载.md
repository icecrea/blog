# 类加载总结

![](https://icecrea-blog-1300414836.cos.ap-beijing.myqcloud.com/blog/类加载全流程.png)



## 类编译

类编译，即 .java 文件通过javac命令编译成 .class 文件，才能在虚拟机上正常运行代码。可以通过 javap查看class文件包含信息。

重点：编译后的**字节码文件**主要包括**常量池和方法表集合**这两部分

- 常量池 ：主要记录的是字节码文件中出现的**字面量**以及**符号引用**

  - **字面常量**包括字符串常量（例如 String str=“abc”，其中”abc”就是常量），声明为 final 的属性以及一些基本类型（例如，范围在 -127-128 之间的整型）的属性。

  - **符号引用**包括类和接口的全限定名、类引用、方法引用以及成员变量引用（例如 String str=“abc”，其中 str 就是成员变量引用）等。

- 方法表集合

  - 包含一些方法的字节码、方法访问权限（public、protect、prviate 等）、方法名索引（与常量池中的方法引用对应）、描述符索引、JVM 执行指令以及属性集合等。



## 类加载流程

类从被加载到虚拟机内存到卸出内存为止，类加载的整个生命周期分为加载-连接-初始化三个阶段。

![](https://icecrea-blog-1300414836.cos.ap-beijing.myqcloud.com/blog/类加载流程.png)

### 1. 加载阶段：

**加载阶段**是 Java 将字节码数据从不同的数据源读取到 JVM 中，并映 射为 JVM 认可的数据结构（Class 对象），这里的数据源可能是各种各样的形态，如 jar 文件、class 文件，甚至是网络数据源等；如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError

加载过程完成以下三件事：

1. 通过一个**类的全限定名**来获取定义此类的**二进制字节流**。
2. 将这个字节流所代表的**静态存储结构**转化为**方法区的运行时存储结构**。 
3. 在内存中生成一个代表这个**类的 Class 对象**，作为方法区这个类的各种数据的访问入口。

>  其中二进制字节流可以从以下方式中获取：
>
>  - 从 ZIP 包读取，从网络中获取，动态代理运行时计算生成，由其他文件生成（如JSP）等

加载阶段即可以使用系统提供的类加载器在完成，也可以由用户自定义的类加载器来完成。加载阶段与连接阶段的部分内容(如一部分字节码文件格式验证动作)是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始。

### 2. 连接阶段
#### 2.1 验证阶段
确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
整体分为4个阶段的校验工作：**文件格式、元数据、字节码、符号引用**

#### 2.2 准备阶段
准备阶段是正式为**类变量(static 成员变量)分配内存**并设置类变量初始值（零值）的阶段，这些变量所使用的内存都将在方法区中进行分配。
这时候进行内存分配的仅包括类变量，而不包括实例变量，**实例变量将会在对象实例化时随着对象一起分配在堆中**。
其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：

```java
public static int value=123;
```
那么，变量value在准备阶段过后的值为0而不是123。因为这时候尚未开始执行任何java方法，而**把value赋值为123的putstatic指令是程序被编译后，存放于类构造器方法之中**，所以把value赋值为123的动作将在初始化阶段才会执行。
“特殊情况”：当类字段的字段属性是常量时，会在准备阶段初始化为指定的值，所以标注为final之后，value的值在准备阶段初始化为123而非0。

#### 2.3 解析阶段
　解析阶段是虚拟机将**常量池内的符号引用**替换为**直接引用**的过程。编译时，Java 类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。类结构文件的常量池中存储了符号引用，包括类和接口的全限定名、类引用、方法引用以及成员变量引用等。如果要使用这些类和方法，就需要把它们转化为 JVM 可以直接获取的内存地址或指针，即直接引用。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。

### 3. 初始化阶段
#### 类何时初始化

虚拟机规范中并没有强制约束何时进行**加载**，但是规范严格规定了有且只有下列五种情况必须对类进行**初始化**（加载、验证、准备都会随着发生）：

> 1.  遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：
		- 使用 new 关键字实例化对象的时候
		- 读取或设置一个类的静态字段的时候（被 final 修饰、已在编译器把结果放入常量池的静态字段除外）
		- 调用一个类的静态方法的时候
2.  使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。
3.  当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
4.  当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；
5.  当使用 JDK.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为REF_getStatic, REF_putStatic, REF_invokeStatic  的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；



初始化阶段才真正开始执行类中的定义的 Java 程序代码。**初始化阶段即虚拟机执行类构造器方法的过程。**在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。

类初始化阶段是类加载过程的最后阶段，在这个阶段中，JVM 首先将执行构造器`<clinit>`方法。编译器会在将 .java 文件编译成 .class 文件时，收集所有类初始化代码，包括静态变量赋值语句、静态代码块、静态方法，收集在一起成为`<clinit>`方法。子类初始化时会首先调用父类的 `<clinit>`方法，再执行子类的`<clinit>`方法。

特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。

```java
  static {
        i = 0;
        //静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。
        //编译报错： Illegal forward reference
        System.out.println(i);
    }

    static int i =1;
```
## 类加载易错题目
**注意**

所有引用类的方式都不会触发初始化称为被动引用，下面是3个被动引用例子：

1. 通过子类引用父类静态字段，不会导致子类初始化；
2. 通过数组定义引用类，不会触发此类的初始化
3. 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用定义常量的类，因此不会触发定义常量的类的初始化

```java
public class SuperClass {
    public static final String HELLO = "hello";

    static {
        System.out.println("super static class");
    }

    public static int value = 123;
}


public class SubClass extends SuperClass{
    static {
        System.out.println("sub static class");
    }
}

public class Main {
    public static void main(String[] args) {
        // 被动引用1 ：子类加载父类静态块，不会导致子类初始化；
        System.out.println(SubClass.value);

        // 被动引用2 ： 通过数组定义引用类，不会触发此类的初始化
        // 触发的是一个虚拟机自动生成的，直接继承于java.lang.Object的子类，创建动作由字节码指令newarray触发。并没有触发真正的SuperClass的初始化
        SuperClass[] sca = new SuperClass[10];

        // 被动引用3 ： 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用定义常量的类，因此不会触发定义常量的类的初始化
        System.out.println(SuperClass.HELLO);
    }
}
```


关于类加载的顺序，分享一个容易出错的实例：


```java
public class Singleton {
    // step 1
    private static Singleton singleton = new Singleton();

    public static int count1;

    // step 2
    // 准备阶段值均为0 赋值为5的pustatic指令，存放于类构造器方法中，初始化阶段执行
    public static int count2 = 5;

    // step 1.2
    private Singleton() {
        count1++;
        count2++;
        System.out.println("constructor init :" + count1 + " ---" + count2);
        System.out.println("constructor init");
    }

    // step 1.1
    // 对象一建立就运行构造代码块了，而且优先于构造函数执行。有对象建立，才会运行构造代码块
    {
        System.out.println("init :" + count1 + " ---" + count2);
        System.out.println("init");
    }

    // step 3
    static {
        System.out.println("static init" + count1 + " ---" + count2);
        System.out.println("static init");
    }

    public static Singleton getInstance() {
        return singleton;
    }

    public static void main(String[] args) {
        Singleton singleton = Singleton.getInstance();
        System.out.println(Singleton.count1);
        System.out.println(Singleton.count2);
    }
}
```



参考：
https://juejin.im/post/5b2357c5f265da597a60f9ec