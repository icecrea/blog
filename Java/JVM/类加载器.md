# 类加载器与双亲委派模型

## 类加载流程

关于类加载流程，详细内容可以参考我的上一篇文章。此处简要总结下。

类加载分为加载-链接-初始化三个阶段：

- 加载：将class文件二进制字节码数据读入jvm的方法区，在堆中生成对应class对象。
- 链接：验证字节信息符合jvm规范，初始化静态变量初始值，将常量池中符号引用替换为直接引用。
- 初始化：执行类初始化逻辑，即`clinit`方法，包括静态变量赋值动作，静态代码块。

本文讨论的类加载器ClassLoader，在**加载阶段**将 class 的字节码转换成class对象。

## 类加载器分类

- **启动类加载器**（Bootstrap Class-Loader），加载 jre/lib 下面的 jar 文件，如 rt.jar。常用内置库 java.xxx.\* 都在里面，如 java.util.\*、java.io.\*、java.nio.\*、java.lang.\* 等
- **扩展类加载器**（Extension or Ext Class-Loader），负责加载我们放到 jre/lib/ext/ 目录下 面的 jar 包
- **应用类加载器**（Application or App Class-Loader），加载 Classpath 环境变量里定义的路径中的 jar 包和目录，也是系统类加载器。

## 类加载器特征

- **双亲委派模型**。是当类加载器（Class-Loader）试图加载某个类型的时候， 除非父加载器找不到相应类型，否则尽量将这个任务代理给当前加载器的父加载器去做。使用委派模型的目的是避免重复加载 Java 类型。

  但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如 JDK 内部的 ServiceProvider/ServiceLoader机制，用户可以在标准 API 框架上，提供自己的实现，JDK 也需要提供些默认的参考实现。 例如， Java 中 JNDI、JDBC、文件系统、Cipher 等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的**上下文加载器**。

- **可见性**，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的，不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。

- **单一性**，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见

## 自定义类加载器

