# MVCC总结

## 一致性读视图

InnoDB在实现MVCC时用到**一致性读视图**，`consistent read view`，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。它没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。

## 快照定义

**可重复读隔离级别下，事务在启动时拍了基于整库的快照。**

InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。（通过执行更新操作时生成的undo log回滚日志）

InnoDB 利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。

> 可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。

## 事务的视图数组与数据版本row trx_id

在实现上， **InnoDB 为每个事务构造了一个数组**，用来保存这个**事务启动瞬间**，当前正在“活跃”的所有事务 ID。
**“活跃”指的就是，启动了但还没提交。**

> 低水位：数组里面事务 ID 的最小值记。
> 高水位：当前系统里面已经创建过的事务 ID 的最大值加 1 。
> 视图数组和高水位，就组成了当前事务的一致性视图（read-view）。



![img](https://icecrea-1300414836.file.myqcloud.com/mysql/mysql45/08_view/view.png)


一个数据版本的 row trx_id，有以下可能：

```
1. 在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；
2. 如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；
3. 如果落在黄色部分，那就包括两种情况
    a. 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；
    b. 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。
```



## 更新逻辑：当前读

**更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。**

除了 update 语句外，select 语句如果加锁，也是当前读。

所以如果把事务 A 的查询语句 `select * from t where id=1`修改一下，加上 `lock in share mode` 或 `for update`，也都可以读到版本号是 101 的数据，返回的 k 的值是 3。



参考：
《mysql实战45讲》丁奇

