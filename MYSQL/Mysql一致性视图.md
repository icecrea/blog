# Mysql一致性视图与隔离级别

## RC与RR的实现方式：一致性读视图

InnoDB在实现MVCC时用到**一致性读视图**，`consistent read view`，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。它没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。

## 快照在MVCC里是如何工作的？

**可重复读隔离级别下，事务在启动时拍了基于整库的快照。**
InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。（通过执行更新操作时生成的undo log回滚日志）

InnoDB 利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。

> 可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。

## 事务的视图数组与数据版本row trx_id

在实现上， **InnoDB 为每个事务构造了一个数组**，用来保存这个**事务启动瞬间**，当前正在“活跃”的所有事务 ID。
**“活跃”指的就是，启动了但还没提交。**

> 低水位：数组里面事务 ID 的最小值记。
> 高水位：当前系统里面已经创建过的事务 ID 的最大值加 1 。
> 视图数组和高水位，就组成了当前事务的一致性视图（read-view）。



![img](https://icecrea-1300414836.file.myqcloud.com/mysql/mysql45/08_view/view.png)


一个数据版本的 row trx_id，有以下可能：



```
1. 在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；
2. 如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；
3. 如果落在黄色部分，那就包括两种情况
    a. 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；
    b. 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。
```

## 实战分析

```
mysql> CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `k` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;
insert into t(id, k) values(1,1),(2,2);
```



![img](https://icecrea-1300414836.file.myqcloud.com/mysql/mysql45/08_view/case.png)


图中事务B查询结果为3，事务A查询结果为1。下面解释原因：



可以先做如下假设

```
1. 事务 A 开始前，系统里面只有一个活跃事务 ID 是 99；
2. 事务 A、B、C 的版本号分别是 100、101、102，且当前系统里只有这四个事务；
3. 三个事务开始前，(1,1）这一行数据的 row trx_id 是 90。
```

事务A的数组为[99,100]，事务B数组为[99,100,101]，事务C数组为[99,100,101,102]

事务 C先把数据从 (1,1) 改成了 (1,2)。这时候，这个数据的最新版本的 row trx_id 是 102，而 90 这个版本已经成为了历史版本。第二个有效更新是事务 B，把数据从 (1,2) 改成了 (1,3)。这时候，这个数据的最新版本（即 row trx_id）是 101，而 102 又成为了历史版本。row trx_id更新过程即为90-》102-》101。

```
事务A读数据，A的视图数组是 [99,100]，
1. 找到当前数据（1，3），row trx_id=101，比高水位大，处于红色区域，不可见；（版本未提交）
2. 找到上一个历史版本，一看 row trx_id=102，比高水位大，处于红色区域，不可见；（版本视图创建后提交）
3. 找到上一个历史版本（1,1)，它的 row trx_id=90，比低水位小，处于绿色区域，可见。
```

更容易理解的分析方法：

```
一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：
1. 版本未提交，不可见；
2. 版本已提交，但是是在视图创建后提交的，不可见；
3. 版本已提交，而且是在视图创建前提交的，可见。
```

读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：

- 在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；
- 在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。

Q: 对上面例子来说，如果改成读提交，对应事务AB查询结果是多少？
注意，`start transaction with consistent snapshot;`表示从该语句开始时创建一个持续整个事务的一致性快照。在读提交隔离级别下，该用法没有意义，等效于
`start transaction`。

A: 对事务B来说，由于当前读结果仍然是3。对事务A来说，结合上述的分析方法，此时（1，3）的更新还未提交不可见。（1，2）的更新已经提交，并且由于每一个语句执行前都会重新算出一个新的视图缘故，属于情况3，（1，2）的提交在视图创建前，可见。A的查询结果为2。

## 更新逻辑：当前读

结论：**更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。**

对事务B来说，更新的时候，当前读拿到的数据是 (1,2)，更新后生成了新版本的数据 (1,3)，这个新版本的 row trx_id 是 101。在执行事务 B 查询语句的时候，一看自己的版本号是 101，最新数据的版本号也是 101，是自己的更新，可以直接使用，所以查询得到的 k 的值是 3。

除了 update 语句外，select 语句如果加锁，也是当前读。
所以如果把事务 A 的查询语句 `select * from t where id=1`修改一下，加上 `lock in share mode` 或 `for update`，也都可以读到版本号是 101 的数据，返回的 k 的值是 3。下面这两个 select 语句，就是分别加了读锁（S 锁，共享锁）和写锁（X 锁，排他锁）。

```
mysql> select k from t where id=1 lock in share mode;
mysql> select k from t where id=1 for update;
```

## 事务隔离级别与存在问题

### 事务隔离级别

- 读未提交：一个事务还没提交时，它做的变更就能被别的事务看到。
- 读提交：一个事务提交之后，它做的变更才会被其他事务看到。
- 可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。（Mysql默认）
- 串行化：顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

### 存在问题

- 更新丢失（Lost Update）
  当多个事务选择同一行操作，并且都是基于最初选定的值，由于每个事务都不知道其他事务的存在，就会发生更新覆盖的问题。类比github提交冲突。

- 脏读（Dirty Reads）
  事务A读取了事务B已经修改但尚未提交的数据。若事务B回滚数据，事务A的数据存在不一致性的问题。

- 不可重复读（Non-Repeatable Reads）
  事务A第一次读取最初数据，第二次读取事务B已经提交的修改或删除数据。导致两次读取数据不一致。不符合事务的隔离性。

- 幻读（Phantom Reads）
  事务A根据相同条件第二次查询到事务B提交的新增数据，两次数据结果集不一致。不符合事务的隔离性。
  幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。

  | 隔离级别                     | 脏读（Dirty Read） | 不可重复读（NonRepeatable Read） | 幻读（Phantom Read） |
  | :--------------------------- | :----------------- | :------------------------------- | :------------------- |
  | 读未提交（Read uncommitted） | 可能               | 可能                             | 可能                 |
  | 读提交（Read committed）     | 不可能             | 可能                             | 可能                 |
  | 可重复读（Repeatable read）  | 不可能             | 不可能                           | 可能                 |
  | 可串行化（Serializable ）    | 不可能             | 不可能                           | 不可能               |

### RR，RC能解决脏读问题么？
A: 可以，脏读指读取了其它事务已修改未提交的数据。RR与RR的实现都依赖一致性视图，区别是生成的时机不同。一个数据版本对一个事务视图来说，除了自己的更新可见，版本未提交或版本在视图创建之后提交，这两种情况均不可见。所以不会读到其它事务未提交数据。

### RR如何解决不可重复读问题？
A: 不可重复读指两次读取数据不一致。在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图。

### 事务的可重复读的能力是怎么实现的？
可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。

### 可重复读会有幻读吗？
幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。注意：幻读仅专指“新插入的行”。

## 总结

InnoDB 的行数据有多个版本，每个数据版本有自己的 row trx_id，每个事务或者语句有自己的一致性视图。普通查询语句是一致性读，一致性读会根据 row trx_id 和一致性视图确定数据版本的可见性。
对于可重复读，查询只承认在事务启动前就已经提交完成的数据；
对于读提交，查询只承认在语句启动前就已经提交完成的数据；



参考：
《mysql实战45讲》丁奇

