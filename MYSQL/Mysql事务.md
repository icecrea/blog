# Mysql事务



## 事务隔离级别

- 读未提交：一个事务还没提交时，它做的变更就能被别的事务看到。
- 读提交：一个事务提交之后，它做的变更才会被其他事务看到。
- 可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。（Mysql默认）
- 串行化：顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

## 脏读/不可重复读/幻读

- 更新丢失（Lost Update）
  

当多个事务选择同一行操作，并且都是基于最初选定的值，由于每个事务都不知道其他事务的存在，就会发生更新覆盖的问题。类比github提交冲突。

- 脏读（Dirty Reads）
  

**事务A读取了事务B已经修改但尚未提交的数据**。若事务B回滚数据，事务A的数据存在不一致性的问题。

- 不可重复读（Non-Repeatable Reads）
  

**事务A第一次读取最初数据，第二次读取事务B已经提交的修改或删除数据**。导致两次读取数据不一致。不符合事务的隔离性。

- 幻读（Phantom Reads）
  

**事务A根据相同条件第二次查询到事务B提交的新增数据**，两次数据结果集不一致。不符合事务的隔离性。
幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。



| 隔离级别                     | 脏读（Dirty Read） | 不可重复读（NonRepeatable Read） | 幻读（Phantom Read） |
| :--------------------------- | :----------------- | :------------------------------- | :------------------- |
| 读未提交（Read uncommitted） | 可能               | 可能                             | 可能                 |
| 读提交（Read committed）     | 不可能             | 可能                             | 可能                 |
| 可重复读（Repeatable read）  | 不可能             | 不可能                           | 可能                 |
| 可串行化（Serializable ）    | 不可能             | 不可能                           | 不可能               |



**RR，RC能解决脏读问题么？**

A: 可以，**脏读指读取了其它事务已修改未提交的数据**。RC与RR的实现都依赖一致性视图，区别是生成的时机不同。一个数据版本对一个事务视图来说，除了自己的更新可见，版本未提交或版本在视图创建之后提交，这两种情况均不可见。所以不会读到其它事务未提交数据。

**RR如何解决不可重复读问题？**

A: 不可重复读指两次读取数据不一致。在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图。

**事务的可重复读的能力是怎么实现的？**

可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。

**可重复读会有幻读吗？**

存在。幻读指事务A根据相同条件第二次查询到其他事务提交的新增数据。产生幻读原因，是行锁只能锁住行，但是插入动作更新的是记录之间的间隙。解决幻读问题innodb引入了间隙锁Gap lock。



