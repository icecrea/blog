# Mysql死锁

#### 死锁和死锁检测

| 事务A                               | 事务B                               |
| ----------------------------------- | ----------------------------------- |
| begin;                              | begin;                              |
| update t set k = k + 1 where id =1; |                                     |
|                                     | update t set k = k + 1 where id =2; |
| update t set k = k + 1 where id =2; |                                     |
|                                     | update t set k = k + 1 where id =1; |

如上表，事务 A 和事务 B 在互相等待对方的资源释放，就是进入了死锁状态。出现死锁后有两种策略：

1. 直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。
   在 InnoDB 中，innodb_lock_wait_timeout 的默认值是 50s。当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出。设置太小又可能导致误判，简单的锁等待。
2. 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。默认开启。
   每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。

每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n) 的操作。假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的 CPU 资源。因此，你就会看到 CPU 利用率很高，但是每秒却执行不了几个事务。

怎么解决由这种热点行更新导致的性能问题呢？

1. 控制并发度。如同一行同时最多只有 10 个线程在更新，那么死锁检测的成本很低。并发控制要放在服务端。

2. 通过将一行改成逻辑上的多行来减少锁冲突。还是以影院账户为例，可以考虑放在多条记录上，比如 10 个记录，影院的账户总额等于这 10 个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的 1/10，可以减少锁等待个数，也就减少了死锁检测的 CPU 消耗。