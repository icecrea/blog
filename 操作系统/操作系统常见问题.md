# 操作系统

## 进程间通信方法？

https://blog.csdn.net/skyroben/article/details/71513385

每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区，进程A把数据从用户空间拷到**内核缓冲区**，进程B再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信。 

不同进程间的通信本质：**进程之间可以看到一份公共资源；而提供这份资源的形式或者提供者不同，造成了通信方式不同**，而 pipe就是提供这份公共资源的形式的一种。

### 1. 管道Pipe

调用pipe创建管道`#include <unistd.h>  int pipe (int fd[2]);`fd参数返回两个文件描述符,fd[0]指向管道的读端,fd[1]指向管道的写端。fd[1]的输出是fd[0]的输入。

1. 父进程创建管道，得到两个⽂件描述符指向管道的两端。
2. 父进程fork出子进程，⼦进程也有两个⽂件描述符指向同⼀管道。
3. 父进程关闭fd[0]，子进程关闭fd[1]，即⽗进程关闭管道读端，⼦进程关闭管道写端（因为**管道只支持单向通信**）。父进程可以往管道⾥写，子进程可以从管道里读，管道是⽤环形队列实现的，数据从写端流⼊从读端流出,这样就实现了进程间通信。

![](https://icecrea-blog-1300414836.cos.ap-beijing.myqcloud.com/blog/管道进程通信1.png)

管道特点：

>  1.管道只允许具有**血缘关系的进程间通信**，如父子进程间的通信。 
>
>  2.半双工的通信方法，管道只允许**单向通信**。 
>
>  3.管道内部保证同步机制，从而保证访问数据的一致性。 
>
>  4.面向字节流 
>
>  5.管道随进程，进程在管道在，进程消失管道对应的端口也关闭，两个进程都消失管道也消失。

### 2. 信号量semophore 

### 3. 信号 signal 

### 4. 消息队列 message queue

### 5. 共享内存 shared memory 

共享内存就是允许两个或多个进程共享一定的存储区。就如同 malloc() 函数向不同进程返回了指向同一个物理内存区域的指针。当一个进程改变了这块地址中的内容的时候，其它进程都会察觉到这个更改。

优点：使用共享内存进行进程间的通信真的是非常方便，而且函数的接口也简单，数据的共享还使**进程间的数据不用传送，而是直接访问内存**，也加快了程序的效率。同时，它也不像匿名管道那样要求通信的进程有一定的父子关系。

缺点：共享内存没有任何的同步与互斥机制，所以要使用信号量来实现对共享内存的存取的同步。

### 6. 套接字 socket 





## 线程间的通信方式

线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。

### 1.  锁机制：包括互斥锁、条件变量、读写锁

互斥锁提供了以排他方式防止数据结构被并发修改的方法。
读写锁允许多个线程同时读共享数据，而对写操作是互斥的。
条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。

### 2. 信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量

### 3. 信号机制(Signal)：类似进程间的信号处理

